names_coefs = c("exp_ret","constant", "MA1",  "threshhold_parm", "AR1")
names_coefs
c(my.optpar$estimate[1], my.optpar$estimate[2]^2,my.optpar$estimate[3]^2,my.optpar$estimate[4] ,my.optpar$estimate[5]^2 )          # make sure to revert squares in parms
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
# my function
start_parms=c(rep(0.5,4),0.1)
opt_parms= nlm(garchEstimation,start_parms,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, th_value = th_value, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
names_coefs = c("exp_ret","constant", paste0("AR_squared",c(1:ar)), paste0("MA_squared",c(1:ar)), "threshhold_parm")
names_coefs
c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma)])           # make sure to revert squares in parms
c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma)])           # make sure to revert squares in parms
names_coefs = c("exp_ret","constant", paste0("AR_squared",c(1:ar)), paste0("MA_squared",c(1:ar)), "threshhold_parm")
names_coefs
c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma)])           # make sure to revert squares in parms
names_coefs = c("exp_ret","constant", "MA1",  "threshhold_parm", "AR1")
names_coefs
c(my.optpar$estimate[1], my.optpar$estimate[2]^2,my.optpar$estimate[3]^2,my.optpar$estimate[4] ,my.optpar$estimate[5]^2 )          # make sure to revert squares in parms
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
# my function
start_parms=c(rep(0.5,4),0.1)
opt_parms= nlm(garchEstimation,start_parms,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, th_value = th_value, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
names_coefs = c("exp_ret","constant", paste0("AR",c(1:ar)), paste0("MA",c(1:ar)), "threshhold_parm")
names_coefs
c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma)])
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
# my function
start_parms=c(rep(0.5,4),0.1)
opt_parms= nlm(garchEstimation,start_parms,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, th_value = th_value, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
names_coefs = c("exp_ret","constant", paste0("AR",c(1:ar)), paste0("MA",c(1:ar)), "threshhold_parm")
names_coefs
c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma)])
names_coefs = c("exp_ret","constant", "MA1",  "threshhold_parm", "AR1")
names_coefs
c(my.optpar$estimate[1], my.optpar$estimate[2]^2,my.optpar$estimate[3]^2,my.optpar$estimate[4] ,my.optpar$estimate[5]^2 )          # make sure to revert squares in parms
my.loglike.t=function(theta) #Estimate an asymmetric GARCH(1,1) model with Student's t innovations
{
n=length(returns)
x.start= mean(returns)
sigmasq.start= var(returns)
data=c(x.start,returns)
my.sigmasq= rep(0,n+1)
my.sigmasq[1]=sigmasq.start
my.sigma=c(sqrt(my.sigmasq[1]),rep(0,n))
my.mean=rep(0,n+1)
for(j in 2:(n+1))
{
my.mean[j]=theta[1] #Constant conditional mean
}
for (i in 2:(n+1))
{
# my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]^2*my.sigmasq[i-1] #GARCH(1,1)
my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*ifelse((data[i-1]-my.mean[i-1])<=0, 1,0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigma[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))+theta[5]^2*my.sigma[i-1] #PGARCH(1,1) with d=1
#my.sigmasq[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))^2+theta[5]^2*my.sigmasq[i-1] #PGARCH(1,1) with d=2
}
#my.sigmasq=my.sigma^2cd
#my.sigmasq=exp(log.sigmasq)
# normdistrib, GARCH 1/1
1/2*sum(log(my.sigmasq[2:(n+1)])) - sum(log(dnorm((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]))))
#tdistrib
# 1/2*sum(log(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6])) - sum(log(dt((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6]),df=theta[6])))+10^(10)*(theta[6]<2)+10^(10)*(theta[6]>10)
}
par.start=c(rep(0.5,4),0.1)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=1)
my.optpar$estimate
names_coefs = c("exp_ret","constant", "MA1",  "threshhold_parm", "AR1")
names_coefs
c(my.optpar$estimate[1], my.optpar$estimate[2]^2,my.optpar$estimate[3]^2,my.optpar$estimate[4] ,my.optpar$estimate[5]^2 )          # make sure to revert squares in parms
my.loglike.t=function(theta) #Estimate an asymmetric GARCH(1,1) model with Student's t innovations
{
n=length(returns)
x.start= mean(returns)
sigmasq.start= var(returns)
data=c(x.start,returns)
my.sigmasq= rep(0,n+1)
my.sigmasq[1]=sigmasq.start
my.sigma=c(sqrt(my.sigmasq[1]),rep(0,n))
my.mean=rep(0,n+1)
for(j in 2:(n+1))
{
my.mean[j]=theta[1] #Constant conditional mean
}
for (i in 2:(n+1))
{
# my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]^2*my.sigmasq[i-1] #GARCH(1,1)
my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
print(((data[i-1]-my.mean[i-1])<=0))
my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*ifelse((data[i-1]-my.mean[i-1])<=0, 1,0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigma[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))+theta[5]^2*my.sigma[i-1] #PGARCH(1,1) with d=1
#my.sigmasq[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))^2+theta[5]^2*my.sigmasq[i-1] #PGARCH(1,1) with d=2
}
#my.sigmasq=my.sigma^2cd
#my.sigmasq=exp(log.sigmasq)
# normdistrib, GARCH 1/1
1/2*sum(log(my.sigmasq[2:(n+1)])) - sum(log(dnorm((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]))))
#tdistrib
# 1/2*sum(log(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6])) - sum(log(dt((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6]),df=theta[6])))+10^(10)*(theta[6]<2)+10^(10)*(theta[6]>10)
}
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=1)
my.loglike.t=function(theta) #Estimate an asymmetric GARCH(1,1) model with Student's t innovations
{
n=length(returns)
x.start= mean(returns)
sigmasq.start= var(returns)
data=c(x.start,returns)
my.sigmasq= rep(0,n+1)
my.sigmasq[1]=sigmasq.start
my.sigma=c(sqrt(my.sigmasq[1]),rep(0,n))
my.mean=rep(0,n+1)
for(j in 2:(n+1))
{
my.mean[j]=theta[1] #Constant conditional mean
}
print(((data[i-1]-my.mean[i-1])<=0))
for (i in 2:(n+1))
{
# my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]^2*my.sigmasq[i-1] #GARCH(1,1)
my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigma[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))+theta[5]^2*my.sigma[i-1] #PGARCH(1,1) with d=1
#my.sigmasq[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))^2+theta[5]^2*my.sigmasq[i-1] #PGARCH(1,1) with d=2
}
#my.sigmasq=my.sigma^2cd
#my.sigmasq=exp(log.sigmasq)
# normdistrib, GARCH 1/1
1/2*sum(log(my.sigmasq[2:(n+1)])) - sum(log(dnorm((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]))))
#tdistrib
# 1/2*sum(log(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6])) - sum(log(dt((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6]),df=theta[6])))+10^(10)*(theta[6]<2)+10^(10)*(theta[6]>10)
}
garchEstimation(theta0start_parms, returns, ar, ma, threshhold,th_value,data_threshhold,type, distribution)
my.loglike.t(start_parms)
start_parms=c(rep(0.5,4),0.1)
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
# Garch Function ----
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
# my function
start_parms=c(rep(0.5,4),0.1)
garchEstimation(theta=start_parms, returns, ar, ma, threshhold,th_value,data_threshhold,type, distribution)
garchEstimation(theta=start_parms, returns, ar, ma, threshhold,th_value,data_threshhold,type, distribution)
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
garchEstimation(theta=start_parms, returns, ar, ma, threshhold,th_value,data_threshhold,type, distribution)
3^2*1.1
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
garchEstimation(theta=start_parms, returns, ar, ma, threshhold,th_value,data_threshhold,type, distribution)
a = seq(1:19)
a>4
data[1:n]
returns[1:n]
returns
returns[1:100]
returns[1:3]
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
# my function
start_parms=c(rep(0.5,4),0.1)
garchEstimation(theta=start_parms, returns, ar, ma, threshhold,th_value,data_threshhold,type, distribution)
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
# my function
start_parms=c(rep(0.5,4),0.1)
garchEstimation(theta=start_parms, returns, ar, ma, threshhold,th_value,data_threshhold,type, distribution)
my.loglike.t(start_parms)
my.loglike.t=function(theta) #Estimate an asymmetric GARCH(1,1) model with Student's t innovations
{
n=length(returns)
x.start= mean(returns)
sigmasq.start= var(returns)
data=c(x.start,returns)
my.sigmasq= rep(0,n+1)
my.sigmasq[1]=sigmasq.start
my.sigma=c(sqrt(my.sigmasq[1]),rep(0,n))
my.mean=rep(0,n+1)
for(j in 2:(n+1))
{
my.mean[j]=theta[1] #Constant conditional mean
}
for (i in 2:(n+1))
{
# my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]^2*my.sigmasq[i-1] #GARCH(1,1)
my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigma[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))+theta[5]^2*my.sigma[i-1] #PGARCH(1,1) with d=1
#my.sigmasq[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))^2+theta[5]^2*my.sigmasq[i-1] #PGARCH(1,1) with d=2
}
#my.sigmasq=my.sigma^2cd
#my.sigmasq=exp(log.sigmasq)
# normdistrib, GARCH 1/1
1/2*sum(log(my.sigmasq[2:(n+1)])) - sum(log(dnorm((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]))))
#tdistrib
# 1/2*sum(log(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6])) - sum(log(dt((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6]),df=theta[6])))+10^(10)*(theta[6]<2)+10^(10)*(theta[6]>10)
}
garchEstimation(theta=start_parms, returns, ar, ma, threshhold,th_value,data_threshhold,type, distribution)
my.loglike.t(start_parms)
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
# my function
start_parms=c(rep(0.5,4),0.1)
opt_parms= nlm(garchEstimation,start_parms,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, th_value = th_value, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
names_coefs = c("exp_ret","constant", paste0("AR",c(1:ar)), paste0("MA",c(1:ar)), "threshhold_parm")
names_coefs
c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma)])
# Audrino fct
par.start=c(rep(0.5,4),0.1)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=1)
my.optpar$estimate
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
# my function
start_parms=c(rep(0.5,4),0.1)
opt_parms= nlm(garchEstimation,start_parms,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, th_value = th_value, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
names_coefs = c("exp_ret","constant", paste0("AR",c(1:ar)), paste0("MA",c(1:ar)), "threshhold_parm")
names_coefs
c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma)])
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$oil
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
# my function
start_parms=c(rep(0.5,4),0.1)
opt_parms= nlm(garchEstimation,start_parms,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, th_value = th_value, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
names_coefs = c("exp_ret","constant", paste0("AR",c(1:ar)), paste0("MA",c(1:ar)), "threshhold_parm")
names_coefs
c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma)])           # make sure to revert squares in parms
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
# my function
start_parms=c(rep(0.5,4),0.1)
opt_parms= nlm(garchEstimation,start_parms,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, th_value = th_value, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
names_coefs = c("exp_ret","constant", paste0("AR",c(1:ar)), paste0("MA",c(1:ar)), "threshhold_parm")
names_coefs
c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma)])           # make sure to revert squares in parms
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
# my function
start_parms=c(rep(0.5,4),0.1)
opt_parms= nlm(garchEstimation,start_parms,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, th_value = th_value, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
names_coefs = c("exp_ret","constant", paste0("AR",c(1:ar)), paste0("MA",c(1:ar)), "threshhold_parm")
names_coefs
c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma)])           # make sure to revert squares in parms
par.start=c(rep(0.5,4),0.1)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=1)
my.optpar$estimate
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$oil
ar = 1
ma = 1
threshhold = T
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
# my function
start_parms=c(rep(0.5,4),0.1)
opt_parms= nlm(garchEstimation,start_parms,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, th_value = th_value, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
names_coefs = c("exp_ret","constant", paste0("AR",c(1:ar)), paste0("MA",c(1:ar)), "threshhold_parm")
names_coefs
c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma)])           # make sure to revert squares in parms
# Audrino fct
par.start=c(rep(0.5,4),0.1)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=1)
my.optpar$estimate
# inputs fct
returns=ts_r$oil
ar = 1
ma = 1
threshhold = F
th_value  = 0 # not optimized within fct
data_threshhold = 0
type = "GARCH"
distribution ="norm"
# my function
start_parms=c(rep(0.5,4),0.1)
opt_parms= nlm(garchEstimation,start_parms,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, th_value = th_value, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
names_coefs = c("exp_ret","constant", paste0("AR",c(1:ar)), paste0("MA",c(1:ar)), "threshhold_parm")
names_coefs
c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma)])
my.loglike.t=function(theta) #Estimate an asymmetric GARCH(1,1) model with Student's t innovations
{
n=length(returns)
x.start= mean(returns)
sigmasq.start= var(returns)
data=c(x.start,returns)
my.sigmasq= rep(0,n+1)
my.sigmasq[1]=sigmasq.start
my.sigma=c(sqrt(my.sigmasq[1]),rep(0,n))
my.mean=rep(0,n+1)
for(j in 2:(n+1))
{
my.mean[j]=theta[1] #Constant conditional mean
}
for (i in 2:(n+1))
{
my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]^2*my.sigmasq[i-1] #GARCH(1,1)
# my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigma[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))+theta[5]^2*my.sigma[i-1] #PGARCH(1,1) with d=1
#my.sigmasq[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))^2+theta[5]^2*my.sigmasq[i-1] #PGARCH(1,1) with d=2
}
#my.sigmasq=my.sigma^2cd
#my.sigmasq=exp(log.sigmasq)
# normdistrib, GARCH 1/1
1/2*sum(log(my.sigmasq[2:(n+1)])) - sum(log(dnorm((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]))))
#tdistrib
# 1/2*sum(log(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6])) - sum(log(dt((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6]),df=theta[6])))+10^(10)*(theta[6]<2)+10^(10)*(theta[6]>10)
}
# Audrino fct
par.start=c(rep(0.5,4),0.1)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=1)
my.optpar$estimate
names_coefs = c("exp_ret","constant", "MA1",  "threshhold_parm", "AR1")
names_coefs
c(my.optpar$estimate[1], my.optpar$estimate[2]^2,my.optpar$estimate[3]^2,my.optpar$estimate[4] ,my.optpar$estimate[5]^2 )          # make sure to revert squares in parms
names_coefs = c("exp_ret","constant", paste0("AR",c(1:ar)), paste0("MA",c(1:ar)), "threshhold_parm")
names_coefs
c(my.optpar$estimate[1], my.optpar$estimate[2]^2,my.optpar$estimate[3]^2,my.optpar$estimate[5]^2 ,my.optpar$estimate[5] )          # make sure to revert squares in parms
my.loglike.t=function(theta) #Estimate an asymmetric GARCH(1,1) model with Student's t innovations
{
n=length(returns)
x.start= mean(returns)
sigmasq.start= var(returns)
data=c(x.start,returns)
my.sigmasq= rep(0,n+1)
my.sigmasq[1]=sigmasq.start
my.sigma=c(sqrt(my.sigmasq[1]),rep(0,n))
my.mean=rep(0,n+1)
for(j in 2:(n+1))
{
my.mean[j]=theta[1] #Constant conditional mean
}
for (i in 2:(n+1))
{
my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]^2*my.sigmasq[i-1] #GARCH(1,1)
# my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigma[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))+theta[5]^2*my.sigma[i-1] #PGARCH(1,1) with d=1
#my.sigmasq[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))^2+theta[5]^2*my.sigmasq[i-1] #PGARCH(1,1) with d=2
}
#my.sigmasq=my.sigma^2cd
#my.sigmasq=exp(log.sigmasq)
# normdistrib, GARCH 1/1
1/2*sum(log(my.sigmasq[2:(n+1)])) - sum(log(dnorm((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]))))
#tdistrib
# 1/2*sum(log(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6])) - sum(log(dt((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6]),df=theta[6])))+10^(10)*(theta[6]<2)+10^(10)*(theta[6]>10)
}
# Audrino fct
par.start=c(rep(0.5,4),0.1)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=1)
my.optpar$estimate
names_coefs = c("exp_ret","constant", paste0("AR",c(1:ar)), paste0("MA",c(1:ar)), "threshhold_parm")
names_coefs
c(my.optpar$estimate[1], my.optpar$estimate[2]^2,my.optpar$estimate[3]^2,my.optpar$estimate[5]^2 ,my.optpar$estimate[4] )          # make sure to revert squares in parms
c(my.optpar$estimate[1], my.optpar$estimate[2]^2,my.optpar$estimate[5]^2,my.optpar$estimate[3]^2 ,my.optpar$estimate[4] )          # make sure to revert squares in parms
names_coefs = c("exp_ret","constant", "MA1",  "threshhold_parm", "AR1")
names_coefs
c(my.optpar$estimate[1], my.optpar$estimate[2]^2,my.optpar$estimate[3]^2,my.optpar$estimate[4]^2 ,my.optpar$estimate[5]^2 )          # make sure to revert squares in parms
