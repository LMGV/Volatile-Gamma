}
if(model_specification_tree$distribution=="t"){
names_parms=  c(names_parms, "shape") # keep df_t > 2 due to likelihood fct
}
garch_coefs = as.data.frame(t(c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma):length(opt_parms$estimate)])))
colnames(garch_coefs) = names_parms
# model evaluation
# stationarity
sum_coefs = sum(garch_coefs[,3:(2+ar+ma)])
if(model_specification_tree$threshhold==T){
sum_coefs=  sum_coefs + sum(returns<=th_value)/(length(returns))*garch_coefs$eta11 # adjust if threshhold is active
}
# model selection
loglik_model =-opt_parms$minimum
aic_model = my_aic(loglik_model, model_specification_tree$number_parms_estimated)
bic_model = my_bic(loglik_model, model_specification_tree$number_parms_estimated, length(returns))
# save model evaluation in list
model_evaluation = list(sum_coefs,loglik_model, aic_model, bic_model)
names(model_evaluation) = c("sum_ar_ma_coefs","log_lik","aic_model","bic_model")
# add model to model selection list
garch_model = list(names(returns_list)[data_iter], returns, garch_coefs, model_specification_tree, model_evaluation, returns_with_date,treeGarchResult$split_order_pruned, returns_with_date,treeGarchResult$split)
names(garch_model) = c("series_name", "return_data", "garch_coefs", "model_specification", "model_evaluation","returns_with_date","treeGarchResult", "treeGarchResultNoPruning")
all_selected_model_tree[[data_iter]] = garch_model
}
# save only tree
saveRDS(all_selected_model_tree, file = paste0(outpathModels,"univariate_garchs_tree_rub.rds"))
# investigate results
for(i in 1:length(all_selected_model_tree)) {
print(all_selected_model_tree[[i]]$series_name)
print(all_selected_model_tree[[i]]$model_specification)
print(all_selected_model_tree[[i]]$garch_coefs)
print(all_selected_model_tree[[i]]$model_evaluation)
}
all_selected_model_tree
garch_model = list(names(returns_list)[data_iter], returns, garch_coefs, model_specification_tree, model_evaluation, returns_with_date,treeGarchResult$split_order_pruned, returns_with_date,treeGarchResult$split)
names(garch_model) = c("series_name", "return_data", "garch_coefs", "model_specification", "model_evaluation","returns_with_date","treeGarchResult", "treeGarchResultNoPruning")
all_selected_model_tree[[data_iter]] = garch_model
all_selected_model_tree$rub_subsample1
all_selected_model_tree$rub_subsample1$1
number_timeframes = 1
returns_list = list()
returns_list_with_date = list()
for (i in 1:length(subsamples_tree)) {
returns_list[[i]]=subsamples_tree[[i]]$return # garch_data_ts_r only contains 1 dataframe. if multiple, then get all series for all timeframes in return_list
returns_list_with_date[[i]]=subsamples_tree[[i]]
}
names(returns_list) = paste0("rub_subsample", seq(1:length(returns_list))) #!! rename if multiple timeframes are estimated
names(returns_list_with_date) = paste0("rub_subsample", seq(1:length(returns_list_with_date)))
# initialize selected model list for all submodels
all_selected_model_tree = vector("list", length = length(returns_list))
names(all_selected_model_tree) = names(returns_list)
# estimate model for all univariate inputs
for(data_iter in 1:length(returns_list)) {
returns = returns_list[[data_iter]]
returns_with_date = returns_list_with_date[[data_iter]]
# estimate GARCH model for given specification_tree (minimize negative loglikelihood)
opt_parms= nlm(garchEstimation,model_specification_tree$start_parms,
returns = returns,  ma = model_specification_tree$number_ma, ar = model_specification_tree$number_ar,
threshhold = model_specification_tree$threshhold_included, th_value = model_specification_tree$th_value, data_threshhold = model_specification_tree$data_threshhold,
distribution=model_specification_tree$distribution,
print.level=0,steptol = 1e-6, iterlim=1000, check.analyticals=T)
# get model parameters
# get same names as in DCC function
names_parms =  c("mu", "omega", paste0("alpha",seq(1:ma)), paste0("beta",seq(1:ar)))
if(model_specification_tree$threshhold==T){
names_parms=  c(names_parms, "eta11") # set asymmetry parameter to 0
}
if(model_specification_tree$distribution=="t"){
names_parms=  c(names_parms, "shape") # keep df_t > 2 due to likelihood fct
}
garch_coefs = as.data.frame(t(c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma):length(opt_parms$estimate)])))
colnames(garch_coefs) = names_parms
# model evaluation
# stationarity
sum_coefs = sum(garch_coefs[,3:(2+ar+ma)])
if(model_specification_tree$threshhold==T){
sum_coefs=  sum_coefs + sum(returns<=th_value)/(length(returns))*garch_coefs$eta11 # adjust if threshhold is active
}
# model selection
loglik_model =-opt_parms$minimum
aic_model = my_aic(loglik_model, model_specification_tree$number_parms_estimated)
bic_model = my_bic(loglik_model, model_specification_tree$number_parms_estimated, length(returns))
# save model evaluation in list
model_evaluation = list(sum_coefs,loglik_model, aic_model, bic_model)
names(model_evaluation) = c("sum_ar_ma_coefs","log_lik","aic_model","bic_model")
# add model to model selection list
garch_model = list(names(returns_list)[data_iter], returns, garch_coefs, model_specification_tree, model_evaluation, returns_with_date,treeGarchResult$split_order_pruned,treeGarchResult$split)
names(garch_model) = c("series_name", "return_data", "garch_coefs", "model_specification", "model_evaluation","returns_with_date","treeGarchResult", "treeGarchResultNoPruning")
all_selected_model_tree[[data_iter]] = garch_model
}
# save only tree
saveRDS(all_selected_model_tree, file = paste0(outpathModels,"univariate_garchs_tree_rub.rds"))
# investigate results
for(i in 1:length(all_selected_model_tree)) {
print(all_selected_model_tree[[i]]$series_name)
print(all_selected_model_tree[[i]]$model_specification)
print(all_selected_model_tree[[i]]$garch_coefs)
print(all_selected_model_tree[[i]]$model_evaluation)
}
all_selected_model_tree$rub_subsample1$treeGarchResultNoPruning
# 3) get subsamples tree
subsamples_tree  = collectSubsamplesTree(returns, split_variables, treeGarchResult$split_order_pruned)
# 4) Estimate and save GARCH for every terminal leaf (here only for RUBUSD)
# input data
# estimate model for each series and timeframe given
number_timeframes = 1
returns_list = list()
returns_list_with_date = list()
for (i in 1:length(subsamples_tree)) {
returns_list[[i]]=subsamples_tree[[i]]$return # garch_data_ts_r only contains 1 dataframe. if multiple, then get all series for all timeframes in return_list
returns_list_with_date[[i]]=subsamples_tree[[i]]
}
names(returns_list) = paste0("rub_subsample", seq(1:length(returns_list))) #!! rename if multiple timeframes are estimated
names(returns_list_with_date) = paste0("rub_subsample", seq(1:length(returns_list_with_date)))
# initialize selected model list for all submodels
all_selected_model_tree = vector("list", length = length(returns_list))
names(all_selected_model_tree) = names(returns_list)
# estimate model for all univariate inputs
for(data_iter in 1:length(returns_list)) {
returns = returns_list[[data_iter]]
returns_with_date = returns_list_with_date[[data_iter]]
# estimate GARCH model for given specification_tree (minimize negative loglikelihood)
opt_parms= nlm(garchEstimation,model_specification_tree$start_parms,
returns = returns,  ma = model_specification_tree$number_ma, ar = model_specification_tree$number_ar,
threshhold = model_specification_tree$threshhold_included, th_value = model_specification_tree$th_value, data_threshhold = model_specification_tree$data_threshhold,
distribution=model_specification_tree$distribution,
print.level=0,steptol = 1e-6, iterlim=1000, check.analyticals=T)
# get model parameters
# get same names as in DCC function
names_parms =  c("mu", "omega", paste0("alpha",seq(1:ma)), paste0("beta",seq(1:ar)))
if(model_specification_tree$threshhold==T){
names_parms=  c(names_parms, "eta11") # set asymmetry parameter to 0
}
if(model_specification_tree$distribution=="t"){
names_parms=  c(names_parms, "shape") # keep df_t > 2 due to likelihood fct
}
garch_coefs = as.data.frame(t(c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma):length(opt_parms$estimate)])))
colnames(garch_coefs) = names_parms
# model evaluation
# stationarity
sum_coefs = sum(garch_coefs[,3:(2+ar+ma)])
if(model_specification_tree$threshhold==T){
sum_coefs=  sum_coefs + sum(returns<=th_value)/(length(returns))*garch_coefs$eta11 # adjust if threshhold is active
}
# model selection
loglik_model =-opt_parms$minimum
aic_model = my_aic(loglik_model, model_specification_tree$number_parms_estimated)
bic_model = my_bic(loglik_model, model_specification_tree$number_parms_estimated, length(returns))
# save model evaluation in list
model_evaluation = list(sum_coefs,loglik_model, aic_model, bic_model)
names(model_evaluation) = c("sum_ar_ma_coefs","log_lik","aic_model","bic_model")
# add model to model selection list
garch_model = list(names(returns_list)[data_iter], returns, garch_coefs, model_specification_tree, model_evaluation, returns_with_date,treeGarchResult$split_order_pruned,treeGarchResult$split_order)
names(garch_model) = c("series_name", "return_data", "garch_coefs", "model_specification", "model_evaluation","returns_with_date","treeGarchResult", "treeGarchResultNoPruning")
all_selected_model_tree[[data_iter]] = garch_model
}
# save only tree
saveRDS(all_selected_model_tree, file = paste0(outpathModels,"univariate_garchs_tree_rub.rds"))
# investigate results
for(i in 1:length(all_selected_model_tree)) {
print(all_selected_model_tree[[i]]$series_name)
print(all_selected_model_tree[[i]]$model_specification)
print(all_selected_model_tree[[i]]$garch_coefs)
print(all_selected_model_tree[[i]]$model_evaluation)
}
all_selected_model_tree$rub_subsample1$treeGarchResultNoPruning
saveRDS(all_selected_model_tree, file = paste0(outpathModels,"univariate_garchs_tree_rub.rds"))
# investigate results
for(i in 1:length(all_selected_model_tree)) {
print(all_selected_model_tree[[i]]$series_name)
print(all_selected_model_tree[[i]]$model_specification)
print(all_selected_model_tree[[i]]$garch_coefs)
print(all_selected_model_tree[[i]]$model_evaluation)
}
# OPTIONAL Model Saving for convinience: add simple model of other series split in same subsamples and save ----
# ! only do if estimated on same time basis
# ! need to adjust to number of splits done
# tree and non-tree model - for one series
# create list
univ_rub_models_compare = list()
univ_rub_models_compare$rub_m1_subsample1 = all_selected_model_tree$rub_subsample1
univ_rub_models_compare$rub_m1_subsample2= all_selected_model_tree$rub_subsample2
univ_rub_models_compare$rub_m2_subsample1 = all_selected_model$rub_all
univ_rub_models_compare$rub_m2_subsample2 = all_selected_model$rub_all
# change sample for non-tree model to tree subsamples
univ_rub_models_compare$rub_m2_subsample1$return_data = univ_rub_models_compare$rub_m1_subsample1$return_data
univ_rub_models_compare$rub_m2_subsample1$return_data_with_date = univ_rub_models_compare$rub_m1_subsample1$return_with_date
univ_rub_models_compare$rub_m2_subsample2$return_data = univ_rub_models_compare$rub_m1_subsample2$return_data
univ_rub_models_compare$rub_m2_subsample2$return_data_with_date = univ_rub_models_compare$rub_m1_subsample2$return_with_date
# save list
saveRDS(univ_rub_models_compare, file = paste0(outpathModels,"univ_rub_models_for_comparision.rds"))
# tree and non-tree model - for different series
# first match dates to get return series
match_sample1 = select(inner_join(all_selected_model_tree$rub_subsample1$returns_with_date, all_selected_model$oil_all$returns_with_date, by="date"), return, date)
match_sample2 = select(inner_join(all_selected_model_tree$rub_subsample2$returns_with_date, all_selected_model$oil_all$returns_with_date, by="date"), return, date)
# match_sample3 = select(inner_join(all_selected_model_tree$rub_subsample3$returns_with_date, all_selected_model$oil_all$returns_with_date, by="date"), return, date)
# match_sample4 = select(inner_join(all_selected_model_tree$rub_subsample4$returns_with_date, all_selected_model$oil_all$returns_with_date, by="date"), return, date)
# create list
univ_oil_rub_models_combined = list()
univ_oil_rub_models_combined$rub_subsample1 = all_selected_model_tree$rub_subsample1
univ_oil_rub_models_combined$rub_subsample2= all_selected_model_tree$rub_subsample2
univ_oil_rub_models_combined$oil_subsample1 = all_selected_model$oil_all
univ_oil_rub_models_combined$oil_subsample2 = all_selected_model$oil_all
# change sample for non-tree model to tree subsamples
univ_oil_rub_models_combined$rub_subsample1$return_data = select(match_sample1, -date)
univ_oil_rub_models_combined$rub_subsample1$return_data_with_date = match_sample1
univ_oil_rub_models_combined$rub_subsample2$return_data = select(match_sample2, -date)
univ_oil_rub_models_combined$rub_subsample2$return_data_with_date = match_sample2
univ_oil_rub_models_combined$oil_subsample1$return_data = select(match_sample1, -date)
univ_oil_rub_models_combined$oil_subsample1$return_data_with_date = match_sample1
univ_oil_rub_models_combined$oil_subsample2$return_data = select(match_sample2, -date)
univ_oil_rub_models_combined$oil_subsample2$return_data_with_date = match_sample2
# save list
saveRDS(univ_oil_rub_models_combined, file = paste0(outpathModels,"univ_oil_rub_tree_models_combined_for_dcc.rds"))
# Optimal fullsample GARCH model ----
# possible model specifications
ma_choices = seq(1:3)
ar_choices = seq(1:3)
threshhold_choices = c(T,F)
th_value  = 0 # not optimized within fct
data_threshhold = 0 # not implemented
distribution_choices =c("normal","t")
# input data
# estimate model for each series and timeframe given
number_timeframes = 1
returns_list=list(garch_data_ts_r_errors$rub_errors, garch_data_ts_r_errors$oil_errors) # garch_data_ts_r only contains 1 dataframe. if multiple, then get all series for all timeframes in return_list
returns_list_with_date = list(data.frame(date=index(garch_data_ts_r_errors), coredata(garch_data_ts_r_errors[,c("rub_errors")])),
data.frame(date=index(garch_data_ts_r_errors), coredata(garch_data_ts_r_errors[,c("oil_errors")]))) # save as data frame
names(returns_list) = c("rub_all","oil_all") #!! rename if multiple timeframes are estimated
names(returns_list_with_date) = c("rub_all","oil_all")
# initialize selected model list for all univeriate series
all_selected_model = vector("list", length = length(returns_list))
names(all_selected_model) = names(returns_list)
# estimate model for all univariate inputs
for(data_iter in 1:length(returns_list)) {
returns = returns_list[[data_iter]]
returns_with_date = returns_list_with_date[[data_iter]]
# inialize result list for one univariate series
garch_model_selection = list()
# estimate all models given choices above
for (dist_iter in 1:length(distribution_choices)){
distribution =distribution_choices[dist_iter] # set distribution
for (th_iter in 1:length(threshhold_choices)){
threshhold = threshhold_choices[th_iter]
for(ar_iter in 1:length(ar_choices)){
ar = ar_choices[ar_iter]
for(ma_iter in 1:length(ma_choices)){
ma = ma_choices[ma_iter]
# GARCH model Estimation
# starting parms
start_parms = c(0,0.1,  rep(0.1/ma,ma), rep(0.9/ar,ar)) # initialize parms.
if(threshhold==T){
start_parms=  c(start_parms, 0) # set asymmetry parameter to 0
}
if(distribution=="t"){
start_parms=  c(start_parms, 6) # keep df_t > 2 due to likelihood fct
}
# get list for input specification
number_parms_estimated = length(start_parms)
model_specification = list(number_parms_estimated,ma,ar,threshhold, distribution,th_value, data_threshhold,start_parms)
names(model_specification) = c("number_parms_estimated","number_ma","number_ar","threshhold_included", "distribution","th_value","data_threshhold","start_parms")
# estimate GARCH model for given specification (minimize negative loglikelihood)
opt_parms= nlm(garchEstimation,model_specification$start_parms,
returns = returns,  ma = model_specification$number_ma, ar = model_specification$number_ar,
threshhold = model_specification$threshhold_included, th_value = model_specification$th_value, data_threshhold = model_specification$data_threshhold,
distribution=model_specification$distribution,
print.level=0,steptol = 1e-6, iterlim=1000, check.analyticals=T)
# get model parameters
# get same sames as in DCC function
names_parms =  c("mu", "omega", paste0("alpha",seq(1:ma)), paste0("beta",seq(1:ar)))
if(model_specification$threshhold==T){
names_parms=  c(names_parms, "eta11") # set asymmetry parameter to 0
}
if(model_specification$distribution=="t"){
names_parms=  c(names_parms, "shape") # keep df_t > 2 due to likelihood fct
}
garch_coefs = as.data.frame(t(c(opt_parms$estimate[1], opt_parms$estimate[2:(2+ar+ma)]^2,opt_parms$estimate[(3+ar+ma):length(opt_parms$estimate)])))
colnames(garch_coefs) = names_parms
# model evaluation
# stationarity
sum_coefs = sum(garch_coefs[,3:(2+ar+ma)])
if(model_specification$threshhold==T){
sum_coefs=  sum_coefs + sum(returns<=th_value)/(length(returns))*garch_coefs$eta11 # adjust if threshhold is active
}
# model selection
loglik_model =-opt_parms$minimum
aic_model = my_aic(loglik_model, model_specification$number_parms_estimated)
bic_model = my_bic(loglik_model, model_specification$number_parms_estimated, length(returns))
# save model evaluation in list
model_evaluation = list(sum_coefs,loglik_model, aic_model, bic_model)
names(model_evaluation) = c("sum_ar_ma_coefs","log_lik","aic_model","bic_model")
# add model to model selection list
garch_model = list(names(returns_list)[data_iter], returns, garch_coefs, model_specification, model_evaluation,returns_with_date)
names(garch_model) = c("series_name", "return_data", "garch_coefs", "model_specification", "model_evaluation","returns_with_date")
garch_model_selection[[length(garch_model_selection)+1]] = garch_model
}
}
}
}
# select optimal model according to AIC / BIC
# initialize criterion value and index for best model
aic_selected_model = c(10^10,0) #
bic_selected_model = c(10^10,0)
names(aic_selected_model)  = c("minimum_AIC","model_position")
names(bic_selected_model)  = c("minimum_bic","model_position")
# find model with lowest value for criterion
for (i in 1:length(garch_model_selection)) {
if (aic_selected_model[1] >garch_model_selection[[i]]$model_evaluation$aic_model){
aic_selected_model[1:2] = c(garch_model_selection[[i]]$model_evaluation$aic_model, i)
}
if (bic_selected_model[1] >garch_model_selection[[i]]$model_evaluation$bic_model){
bic_selected_model[1:2] = c(garch_model_selection[[i]]$model_evaluation$bic_model, i)
}
}
# select model with lowest value for criterion
if (aic_selected_model[2] == bic_selected_model[2]){
print("Same Model selected by AIC and BIC")
selected_model = garch_model_selection[[aic_selected_model[2]]]
print("Model Specification")
print(selected_model$model_specification)
}
if (aic_selected_model[2] != bic_selected_model[2]){
print("Different Model selected by AIC and BIC")
print("Select Model According to BIC")
selected_model = garch_model_selection[[bic_selected_model[2]]]
#selected_model = garch_model_selection[[bic_selected_model[2]]]
#print("Model Specification")
#print(selected_model$model_specification)
}
all_selected_model[[data_iter]] = selected_model
}
# save estimated GARCH-model
saveRDS(all_selected_model, file = paste0(outpathModels,"univariate_garchs_full_sample.rds"))
# investigate results
for(i in 1:length(all_selected_model)) {
print(all_selected_model[[i]]$series_name)
print(all_selected_model[[i]]$model_specification)
print(all_selected_model[[i]]$garch_coefs)
print(all_selected_model[[i]]$model_evaluation)
}
all_selected_model$rub_all$garch_coefs
all_selected_model$rub_all$model_specification
all_selected_model$oil_all$model_specification
# save estimated GARCH-model
saveRDS(all_selected_model, file = paste0(outpathModels,"univariate_garchs_full_sample.rds"))
# OPTIONAL Model Saving for convinience: add simple model of other series split in same subsamples and save ----
# ! only do if estimated on same time basis
# ! need to adjust to number of splits done
# tree and non-tree model - for one series
# create list
univ_rub_models_compare = list()
univ_rub_models_compare$rub_m1_subsample1 = all_selected_model_tree$rub_subsample1
univ_rub_models_compare$rub_m1_subsample2= all_selected_model_tree$rub_subsample2
univ_rub_models_compare$rub_m2_subsample1 = all_selected_model$rub_all
univ_rub_models_compare$rub_m2_subsample2 = all_selected_model$rub_all
# change sample for non-tree model to tree subsamples
univ_rub_models_compare$rub_m2_subsample1$return_data = univ_rub_models_compare$rub_m1_subsample1$return_data
univ_rub_models_compare$rub_m2_subsample1$return_data_with_date = univ_rub_models_compare$rub_m1_subsample1$return_with_date
univ_rub_models_compare$rub_m2_subsample2$return_data = univ_rub_models_compare$rub_m1_subsample2$return_data
univ_rub_models_compare$rub_m2_subsample2$return_data_with_date = univ_rub_models_compare$rub_m1_subsample2$return_with_date
# save list
saveRDS(univ_rub_models_compare, file = paste0(outpathModels,"univ_rub_models_for_comparision.rds"))
# tree and non-tree model - for different series
# first match dates to get return series
match_sample1 = select(inner_join(all_selected_model_tree$rub_subsample1$returns_with_date, all_selected_model$oil_all$returns_with_date, by="date"), return, date)
match_sample2 = select(inner_join(all_selected_model_tree$rub_subsample2$returns_with_date, all_selected_model$oil_all$returns_with_date, by="date"), return, date)
# match_sample3 = select(inner_join(all_selected_model_tree$rub_subsample3$returns_with_date, all_selected_model$oil_all$returns_with_date, by="date"), return, date)
# match_sample4 = select(inner_join(all_selected_model_tree$rub_subsample4$returns_with_date, all_selected_model$oil_all$returns_with_date, by="date"), return, date)
# create list
univ_oil_rub_models_combined = list()
univ_oil_rub_models_combined$rub_subsample1 = all_selected_model_tree$rub_subsample1
univ_oil_rub_models_combined$rub_subsample2= all_selected_model_tree$rub_subsample2
univ_oil_rub_models_combined$oil_subsample1 = all_selected_model$oil_all
univ_oil_rub_models_combined$oil_subsample2 = all_selected_model$oil_all
# change sample for non-tree model to tree subsamples
univ_oil_rub_models_combined$rub_subsample1$return_data = select(match_sample1, -date)
univ_oil_rub_models_combined$rub_subsample1$return_data_with_date = match_sample1
univ_oil_rub_models_combined$rub_subsample2$return_data = select(match_sample2, -date)
univ_oil_rub_models_combined$rub_subsample2$return_data_with_date = match_sample2
univ_oil_rub_models_combined$oil_subsample1$return_data = select(match_sample1, -date)
univ_oil_rub_models_combined$oil_subsample1$return_data_with_date = match_sample1
univ_oil_rub_models_combined$oil_subsample2$return_data = select(match_sample2, -date)
univ_oil_rub_models_combined$oil_subsample2$return_data_with_date = match_sample2
# save list
saveRDS(univ_oil_rub_models_combined, file = paste0(outpathModels,"univ_oil_rub_tree_models_combined_for_dcc.rds"))
#### Pre
# librarys
library(readxl)
library(readr)
library(data.table)
library(tidyverse)
library(stats)
library(ggfortify)
library(zoo)
library(xtable)
library(lubridate)
library(forecast)
library(tseries)
library(xts)
library(quantmod)
library(fGarch)
library(rugarch)
library(rmgarch)
library(psych)
library(MASS)
filter <- dplyr::filter
select <- dplyr::select
setwd("~/GitHub/Volatile-Gamma") # setwd
source("scripts/functions.R") # functions
source("scripts/garchFunction.R") # functions
outpathDescriptive = "output/univariateDescriptives/"
outpathModels =  "output/univariateModels/"
# Import Data ----
garch_data_ts_r  = readRDS("output/univariateDescriptives/garch_data_ts_r.rds") # selected garch data after struc break analysis
garch_data_ts_r_errors = garch_data_ts_r[, c("rub_errors", "oil_errors")]
# load model data:
# static models
all_selected_model  = readRDS("output/univariateModels/univariate_garchs_full_sample.rds")
all_selected_model_tree  = readRDS("output/univariateModels/univariate_garchs_tree_rub.rds")
# DEFINE split_variables
# only lags etc that are included
# garch_data_ts_r should contain all vars
# garch_data_ts_r_errors only returns itself
# Prediction ----
# DEFINE split_variables
# only lags etc that are included
# garch_data_ts_r should contain all vars
# garch_data_ts_r_errors only returns itself
# in sample 1d-head forecasting for RUB
max_lag_prediction = 3
start_date_predictions = "2008-01-10"
end_date_predictions = "2019-12-31"
analysis_variable = c("rub_errors", "oil_errors")
# tree GARCH
# assign models to observations
predict_data = data.frame(date = index(garch_data_ts_r), coredata(garch_data_ts_r)) %>%
mutate(analysis_variable = NA)
model_in_sample_pred = list()
in_sample_pred_result = list()
overall_model_list = list(model_in_sample_pred, in_sample_pred_result)
model_list_choices = list(all_selected_model_tree, all_selected_model[1],all_selected_model[2] )
analysis_variable_choices = c("rub_errors", "oil_errors") # oil errors do not exist for tree so far
overall_model_list
model_list_choices = list(all_selected_model_tree, all_selected_model[1],all_selected_model[2] )
analysis_variable_choices = c("rub_errors", "oil_errors") # oil errors do not exist for tree so far
overall_model_list
# 1) RUBUSE
# TREE MARCH model
# define inputs for function
models = model_list_choices[[1]]
analysis_variable = analysis_variable_choices[1]
predict_data[, colnames(predict_data) == "analysis_variable"] = predict_data[, colnames(predict_data) == analysis_variable]
# predict variance
model_in_sample_pred[[1]] = models
in_sample_pred_result[[1]] = in_sample_forecast(
models = models,
predict_data,
start_date_predictions,
end_date_predictions,
max_lag_prediction
)
model_in_sample_pred
# FULL Sample GARCH model
# define inputs for function
models = model_list_choices[[2]]
analysis_variable = analysis_variable_choices[1]
predict_data[, colnames(predict_data) == "analysis_variable"] = predict_data[, colnames(predict_data) == analysis_variable]
# predict variance
model_in_sample_pred[[2]] = models
in_sample_pred_result[[2]] = in_sample_forecast(
models = models ,
predict_data,
start_date_predictions,
end_date_predictions,
max_lag_prediction
)
# 2) OIL
# FULL Sample GARCH model
# define inputs for function
models = model_list_choices[[3]]
analysis_variable = analysis_variable_choices[2]
predict_data[, colnames(predict_data) == "analysis_variable"] = predict_data[, colnames(predict_data) == analysis_variable]
# predict variance
model_in_sample_pred[[3]] = models
in_sample_pred_result[[3]] = in_sample_forecast(
models = models ,
predict_data,
start_date_predictions,
end_date_predictions,
max_lag_prediction
)
# match dates in in_sample_pred_result
# !remove one missing obs in tree from other dataframes
ind_same_date = in_sample_pred_result[[1]]$date %in% in_sample_pred_result[[2]]$date
in_sample_pred_result[[2]] = in_sample_pred_result[[2]][-ind_same_date,]
ind_same_date = in_sample_pred_result[[1]]$date %in% in_sample_pred_result[[3]]$date
in_sample_pred_result[[3]] = in_sample_pred_result[[3]][-ind_same_date,]
# set names for series and save
names(in_sample_pred_result) = c("rub_tree", "rub", "oil")
names(model_in_sample_pred) = c("rub_tree", "rub", "oil")
saveRDS(in_sample_pred_result,
file = paste0(outpathModels, "in_sample_pred_result.rds"))
names(overall_model_list) = c("models","predictions")
saveRDS(overall_model_list,
file = paste0(outpathModels, "model_and_prediction.rds"))
overall_model_list$predictions
# list with models and predictions
overall_model_list = list(model_in_sample_pred, in_sample_pred_result)
names(overall_model_list) = c("models","predictions")
saveRDS(overall_model_list,
file = paste0(outpathModels, "model_and_prediction.rds"))
overall_model_list$predictions$rub_tree
