filter <- dplyr::filter
select <- dplyr::select
source("scripts/functions.R") # functions
# parameters
quantile_outliers = 0.001 # cut 0.1% of right and left tail
####Data Import####
ts_r = read.table('data/data.csv', sep = ',')
ts_r = xts(ts_r, order.by = as.Date(rownames(ts_r)))
# descriptives / arima. replace later ----
# Remove Outliers via empirical quantiles
ts_r <- ts_r[(ts_r$rub > quantile(ts_r$rub,quantile_outliers)) & (ts_r$rub < quantile(ts_r$rub,1-quantile_outliers)) & (ts_r$oil > quantile(ts_r$oil,quantile_outliers))& (ts_r$oil < quantile(ts_r$oil,1-quantile_outliers))]
####Mean####
print("Mean of Rubel log returns")
mean(ts_r$rub)
print("Mean of oil log returns")
mean(ts_r$oil)
####Summary Statitics####
summary_oil <- describe(ts_r$oil)
summary_rub <- describe(ts_r$rub)
####Test for Normalily QQ plot####
qqnorm(ts_r$rub)
qqline(ts_r$rub)
qqnorm(ts_r$oil)
qqline(ts_r$oil)
jarque.bera.test(ts_r$rub)
jarque.bera.test(ts_r$oil)
####Fit####
# CHECK which method returns plausible results. vary outlier quantile and see if t fits better then
fitdist(as.vector(ts_r$rub),"t", method = "mge", start = list(df=2))
####ACF r####
acf(ts_r$oil, lag.max = 30, plot = TRUE)
acf(ts_r$rub, lag.max = 30, plot = TRUE)
pacf(ts_r$rub, lag.max = 30, plot = TRUE)
pacf(ts_r$oil, lag.max = 30, plot = TRUE)
####ACF r^2####
ts_r2 <- ts_r^2
acf(ts_r2$oil, lag.max = 30, plot = TRUE)
acf(ts_r2$rub, lag.max = 30, plot = TRUE)
####ARIMA####
arma_oil <- auto.arima(ts_r$oil)
arma_rub <- auto.arima(ts_r$rub)
oil_ar <- arma_oil[["arma"]][1]
oil_ma <- arma_oil[["arma"]][2]
rub_ar <- arma_oil[["arma"]][1]
rub_ma <- arma_oil[["arma"]][2]
# Garch Function ----
my.loglike.t=function(theta) #Estimate an asymmetric GARCH(1,1) model with Student's t innovations
{
n=length(returns)
x.start= mean(returns)
sigmasq.start= var(returns)
data=c(x.start,returns)
my.sigmasq= rep(0,n+1)
my.sigmasq[1]=sigmasq.start
my.sigma=c(sqrt(my.sigmasq[1]),rep(0,n))
my.mean=rep(0,n+1)
for(j in 2:(n+1))
{
my.mean[j]=theta[1] #Constant conditional mean
}
for (i in 2:(n+1))
{
#my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]^2*my.sigmasq[i-1] #GARCH(1,1)
my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigma[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])*((data[i-1]-my.mean[i-1])&gt;0)-theta[4]^2*(data[i-1]-my.mean[i-1])*((data[i-1]-my.mean[i-1])<=0)+ theta[5]^2*my.sigma[i-1] #TGARCH(1,1)
#my.sigma[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))+theta[5]^2*my.sigma[i-1] #PGARCH(1,1) with d=1
#my.sigmasq[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))^2+theta[5]^2*my.sigmasq[i-1] #PGARCH(1,1) with d=2
}
#my.sigmasq=my.sigma^2
#my.sigmasq=exp(log.sigmasq)
1/2*sum(log(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6])) - sum(log(dt((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6]),df=theta[6])))+10^(10)*(theta[6]<2)+10^(10)*(theta[6]>10)
}
returns=ts_r$rub
par.start=c(rep(0.5,5),4)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=2)
m1=garchFit(intel.m~arma(1,0)+garch(1,0),data=intel.m,trace=F)
summary(m1)
ug_spec= ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(j,i)), mean.model = NULL, distribution.model="norm")
ug_fit= ugarchfit(spec = ug_spec, data = returns, solver ='hybrid')
ug_fit
my.optpar
my.loglike.t=function(theta) #Estimate an asymmetric GARCH(1,1) model with Student's t innovations
{
n=length(returns)
x.start= mean(returns)
sigmasq.start= var(returns)
data=c(x.start,returns)
my.sigmasq= rep(0,n+1)
my.sigmasq[1]=sigmasq.start
my.sigma=c(sqrt(my.sigmasq[1]),rep(0,n))
my.mean=rep(0,n+1)
for(j in 2:(n+1))
{
my.mean[j]=theta[1] #Constant conditional mean
}
for (i in 2:(n+1))
{
#my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]^2*my.sigmasq[i-1] #GARCH(1,1)
my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigma[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])*((data[i-1]-my.mean[i-1])&gt;0)-theta[4]^2*(data[i-1]-my.mean[i-1])*((data[i-1]-my.mean[i-1])<=0)+ theta[5]^2*my.sigma[i-1] #TGARCH(1,1)
#my.sigma[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))+theta[5]^2*my.sigma[i-1] #PGARCH(1,1) with d=1
#my.sigmasq[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))^2+theta[5]^2*my.sigmasq[i-1] #PGARCH(1,1) with d=2
}
fffffffffff
#my.sigmasq=my.sigma^2cd
#my.sigmasq=exp(log.sigmasq)
# normdistrib, GARCH 1/1
1/2*sum(log(my.sigmasq[2:(n+1)])) - sum(log(dnorm((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]))))
#tdistrib
# 1/2*sum(log(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6])) - sum(log(dt((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6]),df=theta[6])))+10^(10)*(theta[6]<2)+10^(10)*(theta[6]>10)
}
returns=ts_r$rub
par.start=c(rep(0.5,5),4)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=2)
my.optpar
m1=garchFit(intel.m~arma(1,0)+garch(1,0),data=intel.m,trace=F)
summary(m1)
?garchFit
?fitGarch
library(fGarch)
m1=garchFit(intel.m~arma(1,0)+garch(1,0),data=intel.m,trace=F)
summary(m1)
m1=garchFit(returns~garch(1,0),data=returns,trace=F)
summary(m1)
m1=garchFit(returns~garch(1,1),data=returns,trace=F)
summary(m1)
my.optpar
ug_spec= ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(j,i)), mean.model = NULL, distribution.model="norm")
ug_fit= ugarchfit(spec = ug_spec, data = returns, solver ='hybrid')
ug_fit
ug_spec= ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,1)), mean.model = NULL, distribution.model="norm")
ug_fit= ugarchfit(spec = ug_spec, data = returns, solver ='hybrid')
ug_fit
ug_spec= ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,1)), mean.model = list(armaOrder = c(0, 0), include.mean = TRUE), distribution.model="norm")
ug_fit= ugarchfit(spec = ug_spec, data = returns, solver ='hybrid')
ug_fit
ug_spec= ugarchspec(variance.model=list(model="“fGARCH", garchOrder=c(1,1)), mean.model = list(armaOrder = c(0, 0), include.mean = TRUE), distribution.model="norm")
ug_fit= ugarchfit(spec = ug_spec, data = returns, solver ='hybrid')
ug_fit
ug_fit
ug_spec= ugarchspec(variance.model=list(model="“fGARCH", garchOrder=c(1,1)), mean.model = list(armaOrder = c(0, 0), include.mean = TRUE), distribution.model="norm")
ug_fit= ugarchfit(spec = ug_spec, data = returns, solver ='hybrid')
ug_fit
ug_spec= ugarchspec(variance.model=list(model="“fGARCH", garchOrder=c(1,1)), mean.model = list(armaOrder = c(0, 0), include.mean = TRUE), distribution.model="norm")
ug_fit= ugarchfit(spec = ug_spec, data = returns, solver ='hybrid')
ug_fit
ug_spec= ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1,1)), mean.model = list(armaOrder = c(0, 0), include.mean = TRUE), distribution.model="norm")
ug_fit= ugarchfit(spec = ug_spec, data = returns, solver ='hybrid')
ug_fit
ug_spec= ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1,1)), mean.model = list(armaOrder = c(1, 1), include.mean = TRUE), distribution.model="norm")
ug_fit= ugarchfit(spec = ug_spec, data = returns, solver ='hybrid')
ug_fit
ug_spec= ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1,1)), mean.model = list(armaOrder = c(0, 0), include.mean = TRUE), distribution.model="norm")
ug_fit= ugarchfit(spec = ug_spec, data = returns, solver ='hybrid')
ug_fit
ug_spec= ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1,1)), mean.model = list(armaOrder = c(0, 0), include.mean = TRUE), distribution.model="norm")
ug_fit= ugarchfit(spec = ug_spec, data = returns, solver ='“nlminb”')
ug_fit
par.start=c(rep(0.5,5),4)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=2)
my.optpar
m1=garchFit(returns~garch(1,1),data=returns,trace=F)
summary(m1)
fffffffffff
par.start=c(rep(0.5,5),4)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=2)
my.optpar
ug_spec= ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1,1)), mean.model = list(armaOrder = c(0, ), include.mean = TRUE), distribution.model="norm")
ug_fit= ugarchfit(spec = ug_spec, data = returns, solver ='hybrid')
ug_fit
par.start=c(rep(0.5,5),4)
my.optpar= nlm(garchEstimation,par.start,iterlim=1000,print.level=2)
my.optpar
par.start=c(rep(0.5,5),4)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=2)
my.optpar
par.start=c(rep(0.5,5),4)
my.optpar= nlm(garchEstimation,par.start,iterlim=1000,print.level=2)
my.optpar
garchEstimation = function(theta) { # ,returns ,type, distribution
{
n=length(returns)
x.start= mean(returns)
sigmasq.start= var(returns)
data=c(x.start,returns)
my.sigmasq= rep(0,n+1)
my.sigmasq[1]=sigmasq.start
my.sigma=c(sqrt(my.sigmasq[1]),rep(0,n))
my.mean=rep(theta[1],n+1) # constant conditional mean
for (i in 2:(n+1))
{
my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]^2*my.sigmasq[i-1] #GARCH(1,1)
#my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigma[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])*((data[i-1]-my.mean[i-1])&gt;0)-theta[4]^2*(data[i-1]-my.mean[i-1])*((data[i-1]-my.mean[i-1])<=0)+ theta[5]^2*my.sigma[i-1] #TGARCH(1,1)
#my.sigma[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))+theta[5]^2*my.sigma[i-1] #PGARCH(1,1) with d=1
#my.sigmasq[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))^2+theta[5]^2*my.sigmasq[i-1] #PGARCH(1,1) with d=2
}
# normdistrib, GARCH 1/1
1/2*sum(log(my.sigmasq[2:(n+1)])) - sum(log(dnorm((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]))))
#tdistrib
# 1/2*sum(log(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6])) - sum(log(dt((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6]),df=theta[6])))+10^(10)*(theta[6]<2)+10^(10)*(theta[6]>10)
}
}
par.start=c(rep(0.5,5),4)
my.optpar= nlm(garchEstimation,par.start,iterlim=1000,print.level=2)
my.optpar
par.start=c(rep(0.5,5),4)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=2)
my.optpar
par.start=c(rep(0.5,5),4)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=2)
my.optpar
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=2)
my.loglike.t=function(theta) #Estimate an asymmetric GARCH(1,1) model with Student's t innovations
{
n=length(returns)
x.start= mean(returns)
sigmasq.start= var(returns)
data=c(x.start,returns)
my.sigmasq= rep(0,n+1)
my.sigmasq[1]=sigmasq.start
my.sigma=c(sqrt(my.sigmasq[1]),rep(0,n))
my.mean=rep(0,n+1)
for(j in 2:(n+1))
{
my.mean[j]=theta[1] #Constant conditional mean
}
for (i in 2:(n+1))
{
#my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]^2*my.sigmasq[i-1] #GARCH(1,1)
my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigma[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])*((data[i-1]-my.mean[i-1])&gt;0)-theta[4]^2*(data[i-1]-my.mean[i-1])*((data[i-1]-my.mean[i-1])<=0)+ theta[5]^2*my.sigma[i-1] #TGARCH(1,1)
#my.sigma[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))+theta[5]^2*my.sigma[i-1] #PGARCH(1,1) with d=1
#my.sigmasq[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))^2+theta[5]^2*my.sigmasq[i-1] #PGARCH(1,1) with d=2
}
#my.sigmasq=my.sigma^2cd
#my.sigmasq=exp(log.sigmasq)
# normdistrib, GARCH 1/1
1/2*sum(log(my.sigmasq[2:(n+1)])) - sum(log(dnorm((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]))))
#tdistrib
# 1/2*sum(log(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6])) - sum(log(dt((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6]),df=theta[6])))+10^(10)*(theta[6]<2)+10^(10)*(theta[6]>10)
}
returns=ts_r$rub
par.start=c(rep(0.5,5),4)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=2)
my.optpar
garchEstimation = function(theta) { # ,returns ,type, distribution
{
n=length(returns)
x.start= mean(returns)
sigmasq.start= var(returns)
data=c(x.start,returns)
my.sigmasq= rep(0,n+1)
my.sigmasq[1]=sigmasq.start
my.sigma=c(sqrt(my.sigmasq[1]),rep(0,n))
my.mean=rep(theta[1],n+1) # constant conditional mean
for (i in 2:(n+1))
{
my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]^2*my.sigmasq[i-1] #GARCH(1,1)
#my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigma[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])*((data[i-1]-my.mean[i-1])&gt;0)-theta[4]^2*(data[i-1]-my.mean[i-1])*((data[i-1]-my.mean[i-1])<=0)+ theta[5]^2*my.sigma[i-1] #TGARCH(1,1)
#my.sigma[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))+theta[5]^2*my.sigma[i-1] #PGARCH(1,1) with d=1
#my.sigmasq[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))^2+theta[5]^2*my.sigmasq[i-1] #PGARCH(1,1) with d=2
}
# normdistrib, GARCH 1/1
1/2*sum(log(my.sigmasq[2:(n+1)])) - sum(log(dnorm((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]))))
#tdistrib
# 1/2*sum(log(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6])) - sum(log(dt((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6]),df=theta[6])))+10^(10)*(theta[6]<2)+10^(10)*(theta[6]>10)
}
}
par.start=c(rep(0.5,5),4)
my.optpar= nlm(garchEstimation,par.start,iterlim=1000,print.level=2)
my.optpar
par.start=c(rep(0.5,5),4)
my.optpar= nlm(my.loglike.t,par.start,iterlim=1000,print.level=2)
my.optpar
source("scripts/garchFunction.R") # functions
par.start=c(rep(0.5,5),4)
my.optpar= nlm(my.loglike.t,par.start,returns = returns,iterlim=1000,print.level=2)
my.optpar
par.start=c(rep(0.5,5),4)
my.optpar= nlm(my.loglike.t,par.start,returns = returns,iterlim=1000,print.level=2)
my.optpar
source("scripts/garchFunction.R") # functions
par.start=c(rep(0.5,5),4)
my.optpar= nlm(garchEstimation,par.start,returns = returns,iterlim=1000,print.level=2)
my.optpar
par.start=c(rep(0.5,5),4)
my.optpar= nlm(garchEstimation,par.start,returns = returns,iterlim=1000)
my.optpar
my.optpar
my.loglike.t=function(theta) #Estimate an asymmetric GARCH(1,1) model with Student's t innovations
{
n=length(returns)
x.start= mean(returns)
sigmasq.start= var(returns)
data=c(x.start,returns)
my.sigmasq= rep(0,n+1)
my.sigmasq[1]=sigmasq.start
my.sigma=c(sqrt(my.sigmasq[1]),rep(0,n))
my.mean=rep(0,n+1)
for(j in 2:(n+1))
{
my.mean[j]=theta[1] #Constant conditional mean
}
for (i in 2:(n+1))
{
#my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]^2*my.sigmasq[i-1] #GARCH(1,1)
my.sigmasq[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])^2 + theta[4]*(data[i-1]-my.mean[i-1])^2*((data[i-1]-my.mean[i-1])<=0)+theta[5]^2*my.sigmasq[i-1] #GJR-GARCH(1,1)
#my.sigma[i]=theta[2]^2 + theta[3]^2*(data[i-1]-my.mean[i-1])*((data[i-1]-my.mean[i-1])&gt;0)-theta[4]^2*(data[i-1]-my.mean[i-1])*((data[i-1]-my.mean[i-1])<=0)+ theta[5]^2*my.sigma[i-1] #TGARCH(1,1)
#my.sigma[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))+theta[5]^2*my.sigma[i-1] #PGARCH(1,1) with d=1
#my.sigmasq[i]=theta[2]^2+theta[3]^2*(abs((data[i-1]-my.mean[i-1]))-theta[4]*(data[i-1]-my.mean[i-1]))^2+theta[5]^2*my.sigmasq[i-1] #PGARCH(1,1) with d=2
}
#my.sigmasq=my.sigma^2cd
#my.sigmasq=exp(log.sigmasq)
# normdistrib, GARCH 1/1
1/2*sum(log(my.sigmasq[2:(n+1)])) - sum(log(dnorm((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]))))
#tdistrib
# 1/2*sum(log(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6])) - sum(log(dt((data[2:(n+1)]-my.mean[2:(n+1)])/sqrt(my.sigmasq[2:(n+1)]*(theta[6]-2)/theta[6]),df=theta[6])))+10^(10)*(theta[6]<2)+10^(10)*(theta[6]>10)
}
m1=garchFit(returns~garch(1,1),data=returns,trace=F)
summary(m1)
returns=ts_r$rub
type = NULL
distribution = "normal"
# my function
par.start=c(rep(0.5,5),4)
my.optpar= nlm(garchEstimation,par.start,returns = returns, type=type, distribution=distribution ,iterlim=1000)
my.optpar
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
type = NULL
distribution = "normal"
# my function
par.start=c(rep(0.5,5),4)
my.optpar= nlm(garchEstimation,par.start,returns = returns, type=type, distribution=distribution ,iterlim=1000)
my.optpar
par.start=c(rep(0.5,5),4)
my.optpar= nlm(garchEstimation,par.start,returns = returns, type=type, distribution=distribution ,print.level=2,iterlim=1000, check.analyticals
=1)
my.optpar
returns
ts_r$rub
returns-lag(ts_r$rub)
summary(returns-lag(ts_r$rub))
summary((returns-lag(ts_r$rub)^2)
summary((returns-lag(ts_r$rub)^2))
summary((returns-lag(ts_r$rub))^2)
a = seq(1:10)
lag(a)
a[11]
a = seq(1:10)
lag(a)
a[11]
4 %in% a
4 !%in% a
4 %in% a ==F
# Garch Function ----
source("scripts/garchFunction.R") # functions
# my function
par.start=c(rep(0.5,5),4)
my.optpar= nlm(garchEstimation,par.start,returns = returns, type=type, distribution=distribution ,print.level=2,iterlim=1000, check.analyticals
=1)
my.optpar
as.numeric(T)
as.numeric(F)
t
# Garch Function ----
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = F
data_threshhold = NULL
type = "GARCH"
distribution ="norm"
# my function
par.start=c(rep(0.5,5),4)
my.optpar= nlm(garchEstimation,par.start,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
my.optpar
returns=ts_r$rub
ar = 1
ma = 1
threshhold = F
data_threshhold = NA
type = "GARCH"
distribution ="norm"
# my function
par.start=c(rep(0.5,5),4)
my.optpar= nlm(garchEstimation,par.start,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
my.optpar
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = F
data_threshhold = NA
type = "GARCH"
distribution ="norm"
# my function
par.start=c(rep(0.5,5),4)
my.optpar= nlm(garchEstimation,par.start,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
my.optpar
par.start=c(rep(0.5,5))
my.optpar= nlm(garchEstimation,par.start,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
my.optpar
# my function
par.start=c(rep(0.5,4))
my.optpar= nlm(garchEstimation,par.start,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
my.optpar
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = F
data_threshhold = NA
type = "GARCH"
distribution ="norm"
# my function
par.start=c(rep(0.5,4))
my.optpar= nlm(garchEstimation,par.start,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
my.optpar
source("scripts/garchFunction.R") # functions
# inputs fct
returns=ts_r$rub
ar = 1
ma = 1
threshhold = F
data_threshhold = NA
type = "GARCH"
distribution ="nrm"
# my function
par.start=c(rep(0.5,4))
my.optpar= nlm(garchEstimation,par.start,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
my.optpar
distribution ="norm"
# my function
par.start=c(rep(0.5,4))
my.optpar= nlm(garchEstimation,par.start,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
my.optpar
my.optpar= nlm(garchEstimation,par.start,
returns = returns,  ar = ar, ma = ma,
threshhold = 1, data_threshhold = 1,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
my.optpar
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
data_threshhold = NA
type = "GARCH"
distribution ="norm"
# my function
par.start=c(rep(0.5,4))
my.optpar= nlm(garchEstimation,par.start,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
my.optpar
returns=ts_r$rub
ar = 1
ma = 1
threshhold = T
data_threshhold = NA
type = "GARCH"
distribution ="norm"
# my function
par.start=c(rep(0.5,4),1)
my.optpar= nlm(garchEstimation,par.start,
returns = returns,  ar = ar, ma = ma,
threshhold = threshhold, data_threshhold = data_threshhold,
type=type, distribution=distribution,
print.level=2,iterlim=1000, check.analyticals=1)
my.optpar
